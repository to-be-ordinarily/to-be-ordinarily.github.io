{"pages":[],"posts":[{"title":"Github 블로그 width Hexo: 기본 설정편","text":"💡 환경 PC: MacBoock Pro (16-inch, 2021) OS: macOS Monterey Version 12.1 CPU: Apple M1 Pro Memory: 16GB Node.js: v17.4.0. npm: 8.3.1 Git: version 2.34.1 블로그 설정하기 : _config.yml 설정의 범위가 너무 방대해서 설정을 하였지만 누락된것들은 추후 조금씩 업데이트 하겠습니다. Hexo 설정하기 기본 정보 변경 사이트에 표현되는 profile영역이라고 생각하면됩니다. #Line 6 ~12#Sitetitle: '평범한 개발자'subtitle: ''description: ''keywords:author: 'to-be-ordinarily'language: 'ko'timezone: 'Asia/Seoul' 아래 이미지 영역에 표현되는 정보들을 설정한다. 접속URL 포스팅 후 접속하는 URL을 의미합니다. #Line 16url: https://to-be-ordinarily.github.io/ 포스팅 종류 설정 Hexo 포스팅 방법은 draft, post, page로 총 3가지가 있습니다. draft: 포스트 후 로컬 환경에서만 확인 가능합니다. post: deploy시 해당 포스트가 github에 deploy됩니다. page: 공식문서에 아직 확인을 못하여 확인하면 추가하도록하겠습니다. #Line 35default_layout: draft default_layout을 설정하는 이유는 hexo deploy시 /source/_posts에 있는 글들이 github로 commit되기 때문에 작성 중이거나 수정중인 글이 반영되는 처참한 상황이 발생할 수 있습니다. 그래서 Hexo는 draft라는 포스트 하기 전 임시 작업 공간을 만들어 두었습니다. draft영역에 포스팅을 하기 위해서는 아래와 같이 명령어를 입력해야합니다. hexo new draft 'draft-psot-name' 만약을 위해 dfaft에 만들고 완성 후 post로 publish하는 것이 좋습니다. 포스트 생성시 항상 draft를 입력하는 번거로움이 있습니다. 그래서 Line 35 설정을 하면 /source/_draft폴더에 포스트가 생성되기 때문에 deploy에 대한 안정성을 보장할 수 있습니다. 추후 설정하게 되는 속성들은 지속적으로 업데이트하여 공유하도록 하겠습니다.","link":"/2022/01/26/blog-setting/"},{"title":"객체 지향 설계 SOLID","text":"좋은 객체 지향 설계의 5가지 원칙 좋은 객체 지향 설계의 5가지 원칙은 하기 출처에서 공부한 내용이며, 공부 내용을 바탕으로 이해한 부분을 저만의 예시를 추가하여 정리하여 작성합니다. SOLID 클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리 SRP: 단일 책임 원칙 Single Responsibility Principle 하나의 클래스는 하나의 책임만 가져야 한다. 예를 들어 회사에서 마우스를 첫번째 모델 A 출시로 아래와 같이 만들게 되었습니다. class Mouse{ public String model; public Mouse(String Model){ this.model = model; } public int moveLeft(){...} public int moveRight(){...} public int moveTop(){...} public int moveBottom(){...}} 두번재 모델 B 출시는 감도 옵션이 추가되었습니다. class Mause { public int moveLeft(){ if(model.equlse(&quot;B&quot;)){ //감도 옵션 부여 }else{ //기본 옵션 } } ...} 한 클래스는 하나의 책임만 가져야 하지만, 모델이 출시가 됨에 따라 모델별로 분기를 통해 감도 옵션을 부여하게되어 책임이 증가되었기 때무에 SRP 위배가 되었습니다. 아래와 같이 수정하여 SRP 위배사항을 해결할 수 있습니다. //SRP 준수public interface Mouse{ public int moveLeft(); public int moveRight(); public int moveTop(); public int moveBottom();}class ModelA implements Move{ @Override public int moveLeft(){ //기본 옵션 추가 } ...}class ModelB implements Move{ @Override public int moveLeft(){ //감도 옵션 추가 } ...} OCP: 개방 - 폐쇄 원칙 Open / Close Principle 확장에는 열려 있고, 변경에는 닫혀 있다. 극단적인 OCP 위반 예시 사용자가 A마우스를 사용하다 고장이나서 B마우스를 구매하게되었습니다. 이번에 B마우스는 다른 마우스와 다르게 조작이 특이했습니다. 마우스를 클릭을 하면 방향이 이동되고, 방향을 이동하면 클릭이 되는 이상한 마우스였습니다. 이런 경우를 OCP위배라고합니다. (정상적인 설명만 보면 너무 당연하기 때문에 극단적이 설명을 추가하였습니다.) 다시 정리하면 마우스 자체의 기능은 변질되면 안됩니다. 확장에는 열려 있고 : 좋은 마우스이기 때문에 특수 키가 추가되었다. 변경에는 닫혀 있고 : 마우스가 변경되도 동일한 기능을 가지고 있어야한다. 좀 정상적인 예시를 들자고하면 Java의 특징을 예를 들 수 있습니다. OCP를 잘 지킨 예시 Java는 이식성이 높습니다. 변경에는 닫혀 있고 : Java 어느 환경에나 동일한 동작을 갖습니다. (Window, Mac, Linux, Unix) 확장에는 열려 있고 : Java의 기능은 추가되고, 버전이 올라가지만 자바의 본연의 역할은 변경되지 않습니다. LSP: 리스코프 치환 원칙 Liskov Substitution Principle 프로그램의 객체는 프로그램의 정확성을 깨트리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야한다. OCP와 비슷한 성질을 가지고 있습니다. 정확성: 클릭을 하면 클릭이 되고, 방향을 이동하면 방향이 이동되는 기능 자체의 정확성을 유지해야합니다. 하위 타입의 인스턴스: ModelA, Model B도 모두 마우스의 기능을 합니다. 다시 정리하면 프로그램은 프로그램이 추구하는 바와 일치해야하며, 확장된 프로그램의 하위 프로그램은 상위 프로그램과 동일해야합니다. ISP: 인터페이스 분리 원칙 Interface Segregation Principle 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다 마우스 클릭 인터페이스 보다는 아래와 같이 여러개의 기능을 위한 인터페이스가 낫다 public interface Mouse{ public void clickLeft(); public void clickRight();}public interface FunctionA{ public void clickBack();}public interface FunctionB{ public void clickPrev();}public class ModelA implements Mouse, FunctionA{ ...}public class ModelB implements Mouse, FunctionB{ ...} 이와 같이 기능 인터페이스를 분리하고 다중 상속을 하여 여러 기능을 받을 수 있습니다. DPI: 의존관계 역전 원칙 Dependency Inversion Principle 프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.” 사용자는 마우스를 움직이기 위해서는 마우스에 의존해야합니다. 다시 말하면 마우스를 잡고 마우스를 이동시켜야 마우스가 움직인다는 것입니다. 마우스가 어떠한 메커니즘으로 만들었는지를 안다고해도 마우스는 움직이지 않는 것 처럼 말입니다. 예시는 추후 Spring DI(의존주입)에서 다시 한번 언급하도록 하겠습니다. 객체 지향 설계 5가지 SOLID에 대해 간단하게 설명하였습니다. 전체적으로 마우스를 기준으로 객체지향 설계에 대해 이해했던 부분을 풀어보았습니다. 잘못된 사항이나 궁금한 사항은 언제든지 댓글 부탁드립니다. 참조한 강의 : 인프런 스프링-핵심-원리-기본편 도움된 글: 천천히 올바르게","link":"/2022/01/27/solid-principle/"},{"title":"Github 블로그 width Hexo : 설치편","text":"💡 환경 PC: MacBoock Pro (16-inch, 2021) OS: macOS Monterey Version 12.1 CPU: Apple M1 Pro Memory: 16GB Node.js: v17.4.0. npm: 8.3.1 Git: version 2.34.1 블로그를 생성하게된 이유! 구글링 시 블로그를 찾는데 많은 시간을 허비하여 스스로 보기 편한 블로그를 만들어보기로 했습니다. 공식문서가 아직까지는 낯설어 공식문서보는 것을 연습하여 블로그에 기록하기로 했습니다. Github 블로그를 선택한 이유! 퇴사한 회사에서 주로 svn을 사용하여 git을 겸사 겸사 공부해보려고 합니다. Github 블로그 만들기 Github 블로그는 Gthub Page와 정적 사이트 생성기(Static Site Generator)의 조합이라고 보면됩니다. 정적 사이트 생성기는 다양한 종류가 있습니다. 대표적으로 지킬(Jekyll ruby 기반), 헥소(Hexo node.js 기반), 휴고(Hugo go 기반)가 있습니다. 그 중에서 헥소(Hexo node.js 기반)를 선택했습니다. Github Page 생성 공식 페이지를 참고하여 생성하였습니다. 새로운 Repository 생성합니다. Repository name 후 Create Repository합니다. 💡 {계정}.github.io 형식으로 만들여야합니다. 생성된 git페이지를 확인합니다. {계정}.github.io를 브라우저에 입력하여 확인합니다. ex)https://to-be-ordinarily.github.io 지금과 같이 기본 페이지가 표현됩니다. 헥소(Hexo)설치하기 공식 페이지를 참고하여 생성했습니다. Hexo 설치하기 $ npm install hexo-cli -g Hexo 설정하기 # blog 폴더에 Hexo를 초기화합니다.$ hexo init blog# blog 폴더로 이동합니다.$ cd blog#npm 설치합니다.$ npm install Hexo 테마 설정 hexo-theme-icarus 테마를 선택했습니다. #icarus 테마를 clone하여 받는다. $ git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus ✓명령어를 입력하는 경로가 hexo를 초기화 경로여야합니다. vi ./_config.yml#theme의 속성을 icarus로 변경합니다.$ theme: icarus icarus 테마를 위해 필요한 npm 설치 종류 bulma-stylus hexo-component-inferno hexo-renderer-inferno inferno inferno-create-element npm install --save bulma-stylus@0.8.0 hexo-pagination@^2.0.0 hexo-renderer-inferno@^0.1.3 hexo-component-inferno@^1.0.2 inferno@^7.3.3 inferno-create-element@^7.3.3 Hexo 설정 체크 테마 설정만 하여 큰 문제 없이 hexo 로컬 서버가 실행됩니다. # 명령어 입력 후 Hexo is running 표현되면 정상입니다.$ hexo server GitHub Page + Hexo 연동하기 Hexo에서 Git으로 정적파일을 생성후 편하게 배포하기위한 패키지 설치 $ npm install --save hexo-deployer-git _config.yml 설정 deploy: type: git repo: https://github.com/{계정}/{계정}.github.io.git branch: main publish용 정적파일 생성 $ hexo generate Github 배포 $ hexo deploy 정적 파일 생성과 배포 $ hexo d -g 확인 Git Repository에 정상적으로 hexo 설정들이 push되었는지 확인합니다. 로컬 서버 실행하여 테마가 정상적으로 적용 되었는지 확인합니다. hexo server 💡 Tip 사용 편의를 위한 &amp;&amp; 명령어 설정파일 (_config.yml, _config.icarus.yml)은 간혹 clean후 generate를 해야 정상 반영됩니다. &amp;&amp;의 의미는 앞의 명령어가 실행되었을 때 성공한 경우 다음 명령어를 실행합니다. 따라서 아래와 같이 작성하면 hexo clean, hexo 정적 파일 생성, hexo 서버 기동을 순차적으로 진행합니다. $ hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server --watch --draft 다음 포스팅에서는 설정을 변경하도록하겠습니다.","link":"/2022/01/26/blog-install/"}],"tags":[],"categories":[{"name":"github blog","slug":"github-blog","link":"/categories/github-blog/"},{"name":"oop","slug":"oop","link":"/categories/oop/"}]}